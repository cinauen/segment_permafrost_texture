"""
--------------- Create labelling data ------------------
This script prepares the manual labels:
- convert manual vector labels into raster
- overprint small ponds which have been labelled manually on top of the
  other classes
- optionally removes too small shapes
- Calculates per pixel sample weights. Here they include:
    - the shape uncertainty as it was assigned during labelling of the
      baydzherakh class
    - uncertainties along boundaries (they are derived from a proximity map
      and are set to be higher in proximity of the boundaries of specified
      classes (baydzherakhs and ponding areas as these have gradual boundaries)

TO RUN THIS SCRIPT:
- Adjust the input parameters further below


Main steps included:
1) read shapefiles
2) create raster (using grid geometry from reference file)
3) Adjust classes
    - relabel specified classes according to transfer value
    - relabel classes according to relabelling dict
    - add overprint shapes (ponds) to existing raster
    - convert zero values (areas where there was no shape) to background
    - clip to smaller aoi and remove nodata areas outside AOI
        (but use scaled AOI to avoid edge effects during proximity calc)
    - create shapefile
    - OPTOINAL: on shapefile, if required select only certain classes to be kept
    - OPTIONAL: on shapefile, if specified remove small shapes (sometimes error shapes
            are created if in QGis the label boundaries are not exact)
    - create updated raster file with classes
4) Clip raster file to exact AOI
5) Add pixel/sample certainties
    - add patch certainty to specified classes and readjust certainty weights
    - Get uncertainties along boundaries (proximity map)
    - Merge pixel certainties by taking the min values (lowest certainties)
    -  Convert pixel weights to percentage to allow converting to int values
    -  Exclude specified classes from downweighting
6) Merge class numbers and certainties into one array
7) Save final raster


!!!! Note: the raster files are generated by using the
geometry from the original raster image as input.
This ensures that there are no pixel shifts of small structures
--> this can be an issue if use rasterize in QGis which does not create
the exact same raster as the original file (small shifts due to pixel
inconsistencies)

"""

import os
import sys
import numpy as np
import geopandas
from rasterio.enums import Resampling
import xarray as xr


# ---------------------- import custom utils ----------------------
sys.path.insert(0, os.path.abspath(
    os.path.join(os.path.dirname(__file__), '..')))

import preproc.proximity_calc as proximity_calc
import utils.geo_utils as geo_utils
import utils.file_utils as file_utils
import utils.xarray_utils as xarray_utils


# -------------------------- EXAMPLE input -------------------------
# vvvvvvvvvvvvvvvvvvvvvvvvvvvvv INPUTS vvvvvvvvvvvvvvvvvvvvvvvvvvv
# List patches numbers (e.g. for test patches test-01, test-02, test-04)
if True:
    # !!!! EXAMPLE INPUT
    patch_num_lst = [1]

    site = 'BLyaE'
    sensor = 'HEX1979'
    proj_folder = f'{site}_v1'

    # phase can be 'test', 'fine_tune', 'training'
    phase = 'test'
    # dictionary to save important parameters
    PARAM = {}
    PARAM['label_version'] = 'Lv01'  # label version for file naming

    # ------ Reference file ------
    # This is used as reference for the raster grid
    PARAM['file_ref'] = 'BLyaE_HEX1979_D3C1215-301069F003_georef_v1_reduced.tif'

    # ----- input shapefile definitions --------
    # name of attribute columns
    class_num_attr = 'raster_val'  # Column name for classes
    confidence_attr = 'clear'  # Column name for class confidence (contains
    # the uncertainty class for the baydzherakh class: 2 very clear 0 not clear)
    transfer_attr = 'transfer'  # Column name for transfer to another class.
    # This was used for the intially labelled height center polygons (HCPs).
    # But as there were not enough HCPs they were not included in the training
    # and the transfer class was used to define the other class to be used instead.

    file_name_struct_labelling_AOI = f"{site}_labelling_AOI_32654_{phase}-{{:02d}}.geojson"

    # name structure of files with baydzherakh, gully, snow, ponding areas
    file_name_struct_base_shape = f"{site}_{sensor}_test_patch{{}}_labels_{PARAM['label_version']}_base.geojson"

    # List of required inputs for shapes to be overlain (=small ponds)
    # this can contain several files (reate sublist per file)
    # [[file_name_struct, class_num_attr, num_overlay_class]]
    struct_overprint_shape = [
        [f"{site}_{sensor}_test_patch{{}}_labels_{PARAM['label_version']}_ponds.geojson",
        class_num_attr, 5]]

    # ------ image properties
    PARAM['EPSG_TARGET'] = 32654
    PARAM['RESOLUTION'] = 1.5  # target image resolution


    # ------------ class number and shape adjustments ------
    # --------- if use transfer value for certain class
    # during manual labelling we assigned created an ice wedge poygon class (3)
    # However, as an option to exclude this additional class due to a lack of
    # class representations we added an additional transfer value which
    # can be used instead.
    # The "base_shape_transfer_class" parameter specifies for which class the
    # class number from the transfer attribute should be used
    # With None the initial class numbering is used.
    PARAM['base_shape_transfer_class'] = 3
    #  !!!! Note this transfer is applied before any other relabeling

    # --- if relabeling is required {from: to}
    # relabeling order is
    # 1) instead of class value use transfer value (for a specified class number)
    # 2) relabel base shape
    # 3) relabel background
    PARAM['relabel_base_shape'] = {}  # {1: 4, 2: 5, 3:0, 4:0, 5: 0}
    # relabel area outside shapes (background) in our case the stable_area
    PARAM['relabel_background'] = {0: 3}
    # assign certainty ratio to certainty level
    PARAM['relabel_base_shape_certainty'] = {0: 0.6, 1: 0.8, 2: 1.0}


    # !!! ---this filtering is only done on shapefile at final processing
    # if only want to export certain labels as shapefile
    PARAM['label_query'] = None  # 'raster_val < 3 and raster_val != 0'


    # --- define patch types to be removed (e.g. too small area for a certai class)
    # e.g. remove too small areas, these patches will be interpolated to
    # to surrounding raster values (such that don't get holes)
    min_cells = 10
    min_area_gully = (PARAM['RESOLUTION']**2 * min_cells)/1000000
    min_cells = 3
    min_area_pond = (PARAM['RESOLUTION']**2 * min_cells)/1000000
    PARAM['patch_remove_query'] = [
        'raster_val == 4 and area_km < @min_area_gully',
        'raster_val == 5 and area_km < @min_area_pond']

    # To which classses to apply shapes weights
    # (from attribute table confidence_attr)
    class_lst_incl_shape_weights = [1]  # use certainties for baydzheralhs

    # For which classes th certainty weighting should not be considered at all
    # For the specified classes the certainty will be set to 100% at end
    class_lst_exclude_uncertainties = [4, 5, 6]

    # --- boundary uncertainty parameters
    # shapes for whose boundaries the proxmity should be calculated
    query_proximity = [
        'area_km > (1.5*1.5/1000000)*3 and raster_val == 1',  # for baydzherakhs
        'area_km > (1.5*1.5/1000000)*3 and raster_val == 2'  # for ponding areas
        ]
    # broadness of the uncertainty boundaries per list item in query_proximity
    boundary_half_rad = [
        3.0,  # thinner boundary for baydzherakhs
        6.0  # thicker boundary for ponding areas
        ]

    # outut type offinal label file
    # !!! Note: int values need to be high enough such that sample certainties
    #     for which the largest value is 100
    output_dtype = 'uint8'

    # ---------------------- PATHS ------------------------
    # set paths (if required change here or change add_base_path.py)
    BASE_PATH = os.path.abspath(
        os.path.join(os.path.dirname(__file__), '../../'))
    sys.path.insert(0, BASE_PATH)
    import example.add_base_path
    path_proc_inp, path_temp_inp = example.add_base_path.main()
    # base processing/project path
    PATH_PROC = os.path.join(
        path_proc_inp, '1_site_preproc', proj_folder)

    # --- set paths for input and labels
    # input folder: reference image and AOIs
    PARAM['PATH_INP'] = os.path.join(PATH_PROC, '01_input')
    # input and output folder for segmentation files
    PARAM['PATH_LABELS'] = os.path.join(PATH_PROC, '00_labelling')

    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
elif False:
    patch_num_lst = list(range(0, 8))

    site = 'FadN'
    sensor = 'SPOT2018'
    proj_folder = 'FadN_v3_pred'  # f'{site}_v1'

    # phase can be 'test', 'fine_tune', 'training'
    phase = 'test'
    # dictionnary to save important parameters
    PARAM = {}
    PARAM['label_version'] = 'Lv03'  # label version for file naming

    # ------ Reference file ------
    # This is used as reference for the raster grid
    PARAM['file_ref'] = 'IMG_SPOT7_P_201808120330552_ORT_6228422101_R1C1_v3_min_max_16bit_coreg_local.TIF'
    # FadN HEX1979: 'D3C1216200448F004_b_FadN1980_georef_toWV_v1_res1-5m_clip_v3_min_max_8bit_coreg_local.tif'
    # FadN SPOT2018: 'IMG_SPOT7_P_201808120330552_ORT_6228422101_R1C1_v3_min_max_16bit_coreg_local.TIF'

    # ----- input shapefile definitions --------
    # name of attribute which contains the uncertainty class for a specific shape
    class_num_attr = 'raster_val'
    confidence_attr = 'clear'  # !!! ONLY considered for base file
    transfer_attr = 'transfer'  # !!! ONLY considered for base file

    file_name_struct_labelling_AOI = f"{site}_labelling_AOI_32654_{phase}-{{:02d}}.geojson"

    # name structure of files with baydzherakh, gully, snow, ponding areas
    # BLyakhE_HEX1979_test_seg_out_clip_Lv03_test-patches_patch0_edit.geojson
    file_name_struct_base_shape = f"{site}_{sensor}_{phase}_seg_out_clip_{PARAM['label_version']}_{phase}-patches_patch{{}}_edit.geojson"

    # List of required inputs for shapes to be overlain (=small ponds)
    # this can contain several files (reate sublist per file)
    # [[file_name_struct, class_num_attr, num_overlay_class]]
    struct_overprint_shape = [
        [f"{site}_{sensor}_{phase}_seg_out_clip_{PARAM['label_version']}_{phase}-patches_patch{{}}_ponds_edit.geojson",
         class_num_attr, 5]]

    # ------ image properties
    PARAM['EPSG_TARGET'] = 32654
    PARAM['RESOLUTION'] = 1.5  # target image resolution

    # ------------ class number and shape adjustments ------
    # --------- if use transfer value for certain class
    # during manual labelling we assigned created an ice wedge poygon class (3)
    # However, as an option to exclude this additional class due to a lack of
    # class representations we added an additional transfer value which
    # can be used instead.
    # The "base_shape_transfer_class" parameter specifies for which class the
    # class number from the transfer attribute should be used
    # With None the initial class numbering is used.
    PARAM['base_shape_transfer_class'] = 3
    #  !!!! Note this transfer is applied before any other relabeling

    # --- if relabeling is required {from: to}
    # relabeling order is
    # 1) instead of class value use transfer value (for a specified class number)
    # 2) relabel base shape
    # 3) relabel background
    PARAM['relabel_base_shape'] = {}  # {1: 4, 2: 5, 3:0, 4:0, 5: 0}
    # relabel area outside shapes (background) in our case the stable_area
    PARAM['relabel_background'] = {0: 3}
    # assign certainty ratio to certainty level
    PARAM['relabel_base_shape_certainty'] = {0: 0.6, 1: 0.8, 2: 1.0}


    # !!! ---this filtering is only done on shapefile at final processing
    # if only want to export certain labels as shapefile
    PARAM['label_query'] = None  # 'raster_val < 3 and raster_val != 0'


    # --- define patch types to be removed (e.g. too small area for a certai class)
    # e.g. remove too small areas, these patches will be interpolated to
    # to surrounding raster values (such that don't get holes)
    min_cells = 10
    min_area_gully = (PARAM['RESOLUTION']**2 * min_cells)/1000000
    min_cells = 3
    min_area_pond = (PARAM['RESOLUTION']**2 * min_cells)/1000000
    PARAM['patch_remove_query'] = [
        'raster_val == 4 and area_km < @min_area_gully',
        'raster_val == 5 and area_km < @min_area_pond']

    # To which classses to apply shapes weights
    # (from attribute table confidence_attr)
    class_lst_incl_shape_weights = [1]  # use certainties for baydzheralhs

    # For which classes th certainty weighting should not be considered at all
    # For the specified classes the certainty will be set to 100% at end
    class_lst_exclude_uncertainties = [4, 5, 6]

    # --- boundary uncertainty parameters
    # shapes for whose boundaries the proxmity should be calculated
    query_proximity = [
        'area_km > (1.5*1.5/1000000)*3 and raster_val == 1',  # for baydzherakhs
        'area_km > (1.5*1.5/1000000)*3 and raster_val == 2'  # for ponding areas
        ]
    # broadness of the uncertainty boundaries per list item in query_proximity
    boundary_half_rad = [
        3.0,  # thinner boundary for baydzherakhs
        6.0  # thicker boundary for ponding areas
        ]

    # outut type offinal label file
    # !!! Note: int values need to be high enough such that sample certainties
    #     for which the largest value is 100
    output_dtype = 'uint8'

    # ---------------------- PATHS ------------------------
    # set paths (if required change here or change add_base_path.py)
    BASE_PATH = os.path.abspath(
        os.path.join(os.path.dirname(__file__), '../../'))
    sys.path.insert(0, BASE_PATH)
    import example.add_base_path
    path_proc_inp, path_temp_inp = example.add_base_path.main()
    # base processing/project path
    PATH_PROC = os.path.join(
        path_proc_inp, '1_texture_proc', proj_folder)

    # --- set paths for input and labels
    # input folder: reference image and AOIs
    PARAM['PATH_INP'] = os.path.join(PATH_PROC, '01_input')
    # input and output folder for segmentation files
    PARAM['PATH_LABELS'] = os.path.join(PATH_PROC, '00_labelling')

    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

# ---------------- loop through different patch numbers ----------------
for patch_num in patch_num_lst:
    area = 'patch' + str(patch_num)
    PARAM['prefix_out'] = f'{site}_{sensor}_{phase}_{area}'

    # -------------- input name assigments --------------
    # base file [geojson_filename, attribute_of_class]
    PARAM['label_base'] = [
        file_name_struct_base_shape.format(patch_num), class_num_attr]
    # base file [geojson_filename, attribute_of_class]
    PARAM['label_overlay'] = [
        [x.format(patch_num), y, z] for x, y, z in struct_overprint_shape]

    PARAM['base_shape_certainty'] = [
        file_name_struct_base_shape.format(patch_num), confidence_attr]

    # if transfer from one class into another
    PARAM['base_shape_transfer'] = [
        file_name_struct_base_shape.format(patch_num), transfer_attr]

    PARAM['AOI_label_area'] = file_name_struct_labelling_AOI.format(
        patch_num)

    # define reformatting on columns of gdf (this is required since if
    # there are inconsitencies get inconsistencies when transfering
    # between raster and shapes)
    col_reformat = {
        PARAM['label_base'][1]: float,
        PARAM['base_shape_certainty'][1]: float,
        PARAM['base_shape_transfer'][1]: float}

    # -------------- save parameters to file --------------
    file_utils.write_param_file(
        PARAM['PATH_LABELS'],
        f"{proj_folder}_{sensor}_{phase}_{area}_{PARAM['label_version']}_label_prep_PARAM.txt",
        {'param_all': PARAM}, manual_inputs=None, how='a', close=False)


    # -------------------- load clip AOI ---------------------
    AOI_FILE = os.path.join(PARAM['PATH_INP'], PARAM['AOI_label_area'])
    AOI_coords, AOI_poly = geo_utils.read_transl_geojson_AOI_coords_single(
        AOI_FILE, PARAM['EPSG_TARGET'])


    # ------------------ read reference file --------------
    # (geometry of this file is used to translate the shape file into raster)
    file_ref = os.path.join(PARAM['PATH_INP'], PARAM['file_ref'])
    img_ref = geo_utils.read_to_xarray(
        file_ref, mask_nan=False, chunk=None)


    # ------------- read shapefiles and create raster ---------------
    # -- labels
    labels_gdf = geopandas.read_file(
        os.path.join(PARAM['PATH_LABELS'], PARAM['label_base'][0]))
    # make sure that values have the correct format
    labels_gdf = labels_gdf.astype(col_reformat)
    raster_base_label = geo_utils.create_raster_from_gdf(
        img_ref.astype(float), labels_gdf, PARAM['label_base'][1], fillval=0)

    # -- certainty levels
    labels_gdf = geopandas.read_file(
        os.path.join(PARAM['PATH_LABELS'], PARAM['base_shape_certainty'][0]))
    # make sure that values have the correct format
    labels_gdf = labels_gdf.astype(col_reformat)
    raster_base_certainty = geo_utils.create_raster_from_gdf(
        img_ref.astype(float), labels_gdf, PARAM['base_shape_certainty'][1], fillval=0)

    # -- transfer levels
    labels_gdf = geopandas.read_file(
        os.path.join(PARAM['PATH_LABELS'], PARAM['base_shape_transfer'][0]))
    # make sure that values have the correct format
    labels_gdf = labels_gdf.astype(col_reformat)
    raster_base_transfer = geo_utils.create_raster_from_gdf(
        img_ref.astype(float), labels_gdf, PARAM['base_shape_transfer'][1], fillval=999)


    # ---------- relabel specified class according to transfer value
    # relabel classes of base shape file accordinag to transfer value that was
    # specified in shape file (hee transfer clas 3 which was labelled as ice
    # wedge poygons eiter to class stabilisd area or to class baydzherakhs)
    if PARAM['base_shape_transfer_class'] is not None:
        raster_base_label = raster_base_label.where(
            raster_base_label != PARAM['base_shape_transfer_class'], raster_base_transfer)
    # take value form xarray where val is not 3
    # other wise use transver value

    # --------- relabel classes according to renumering dict
    raster_base_label = geo_utils.relabel_img(
        raster_base_label, PARAM['relabel_base_shape'])


    # ------- add overprint shapes (ponds) to existing raster
    # this overprints the ponds onto the current labelling raster
    mask_include = {}
    # copy original
    # seg_arr = raster_base_label.copy()

    for i_file, i_class_attr, i_class_num in PARAM['label_overlay']:

        labels_gdf = geopandas.read_file(
            os.path.join(PARAM['PATH_LABELS'], i_file))
        # use only available columns for dtype conversion
        col_reformat1 = {x: col_reformat[x] for x in
                         labels_gdf.columns.intersection(col_reformat.keys())}
        labels_gdf = labels_gdf.astype(col_reformat1)
        raster_overprint_labels = geo_utils.create_raster_from_gdf(
            img_ref, labels_gdf, i_class_attr, fillval=0)

        # get mask (mask all but not the selected class e.g. ponds)
        mask_include = raster_overprint_labels != i_class_num
        raster_base_label = raster_base_label.where(mask_include, other=i_class_num)

    # ------ convert areas where there was no shape to background ----
    raster_base_label = geo_utils.relabel_img(
        raster_base_label, PARAM['relabel_background'])

    # ----- clip raster label to have smaller size ------
    # Due to ref_img as geometric reference the label raster is too large
    # (in particular for test patches). Use scaled AOI to reduce size.
    # However, to avoid edge effect in the proximity calculation
    # enlarge the AOI slightly by 100 picels on each side
    aoi_scaled = geo_utils.scale_AOI(
        AOI_poly, PARAM['RESOLUTION'], -100, PARAM['EPSG_TARGET'],
        path=None, filename='AOI_scaled')
    raster_base_label = geo_utils.clip_to_aoi_gdf(
        raster_base_label, aoi_scaled, from_disk=False, drop_na=True)

    # ---- again create shapefile
    gdf = geo_utils.create_shapefile_from_raster(
        raster_base_label, class_num_attr, PARAM['EPSG_TARGET'],
        unit='km')

    # ---- if specified, select only certain classes to be kept
    # use this if only export certain shapefies but not background
    if PARAM['label_query'] is not None:
        gdf = gdf.query(PARAM['label_query'])

    # --- plot histogram of the shape distribution
    path_fig = os.path.join(
        PARAM['PATH_LABELS'], f"{PARAM['prefix_out']}_class_distribution.pdf")
    gdf['area_m'] = gdf['area_km']*1000000
    geo_utils.plot_shape_distribution(gdf, path_fig, class_num_attr,
                                      attr_col='area_m')


    # ---- remove small shapes if specified
    # e.g. to remove too small gully parts
    # need to assign those with nodata values and then interpolate in
    # order to not create holes e.g. in gully base (if ponds in gully base)
    if PARAM['patch_remove_query'] is not None:
        for i in PARAM['patch_remove_query']:
            # get index of shapes to be removed
            rem_ind = gdf.query(i).index
            gdf.loc[rem_ind, class_num_attr] = 99

        # create new raster iwth removed shapes
        raster_base_label = geo_utils.create_raster_from_gdf(
            raster_base_label, gdf, class_num_attr, fillval=0)

        # set nodata for interpolation
        raster_base_label.rio.write_nodata(99, inplace=True)
        raster_base_label = raster_base_label.rio.interpolate_na(method='nearest')

        # reset nodata value
        raster_base_label.rio.write_nodata(0, inplace=True)

        # create updated shapefile (is used to extract coundary uncertainties
        # further below)
        gdf = geo_utils.create_shapefile_from_raster(
            raster_base_label, class_num_attr, PARAM['EPSG_TARGET'],
            unit='km')
    else:
        # create new raster with adjusted classes (gdf does not have to
        # be recreated here)
        raster_base_label = geo_utils.create_raster_from_gdf(
            raster_base_label, gdf, class_num_attr, fillval=0)


    # -------------- Clip raster file to exact AOI -------
    raster_base_label = geo_utils.clip_to_aoi(
        raster_base_label, AOI_coords, drop_na=True, from_disk=False)
    raster_base_certainty = geo_utils.clip_to_aoi(
        raster_base_certainty, AOI_coords, drop_na=True, from_disk=False)
    # make sure that grids fit
    raster_base_certainty = raster_base_certainty.rio.reproject_match(
            raster_base_label, Resampling=Resampling.nearest)


    # -------------------- Add patch certainty -----------------
    # ----correct quali file
    # 1_ include only certainty levels for classes specified in
    # class_lst_incl_shape_weights
    # (certaintly levels: 2 is best and 0 is worst)

    # create mask with classes for which shape certainty should be used
    mask_include = np.isin(raster_base_label, class_lst_incl_shape_weights)
    raster_base_certainty = raster_base_certainty.where(mask_include, other=2)

    # change values of class weights as specified in dict
    raster_base_certainty = geo_utils.relabel_img(
        raster_base_certainty, PARAM['relabel_base_shape_certainty'])


    # --------------- get uncertainties along boundaries --------------
    # for this use proximity map
    xr_concat = []
    for i_rad, i_query in zip(boundary_half_rad, query_proximity):
        poly_lst = gdf.query(i_query).geometry.tolist()
        if len(poly_lst) > 0:
            dist_lst = proximity_calc.get_proximity_from_gdf(
                poly_lst, raster_base_label, n_jobs=15, px_size=1.5)
            xr_concat.append(proximity_calc.merge_proximity_to_weight(
                dist_lst, raster_base_label, shift=0.5, half_rad=i_rad))

    if len(xr_concat) > 0:
        # Note: the noata value sis usually lost afer certain functions
        #   and has to be added again

        # concatenate the Boundary certainties for different class boundaries
        # and use pixel minimum (lowest certainty)
        xr_prox = xr.concat(
            xr_concat, dim='prox').min(dim='prox').expand_dims(band=[1])
        xr_prox.rio.write_nodata(0, inplace=True)

        # make sure that the grids match
        xr_prox = xr_prox.rio.reproject_match(
                raster_base_certainty, Resampling=Resampling.nearest)

        # clip to exact AOI
        xr_prox = geo_utils.clip_to_aoi(
            xr_prox, AOI_coords, drop_na=True, from_disk=False)

        # concatenate the shape certainty and the boundary certainties
        # and use use pixel minimum (lowest certainty)
        raster_base_certainty = xr.concat(
            [raster_base_certainty, xr_prox], dim='band').min(dim='band')
        raster_base_certainty.rio.write_nodata(0, inplace=True)
        raster_base_certainty = raster_base_certainty.expand_dims(band=[1])


    # -- calculate certainty percentages to allow converting to int
    raster_base_certainty = (raster_base_certainty*100).astype(output_dtype)

    # --- exclude specified classes from downweighting
    mask_exclude =  np.isin(raster_base_label, class_lst_exclude_uncertainties)
    raster_base_certainty = raster_base_certainty.where(
        ~mask_exclude, other=100)
    raster_base_certainty.rio.write_nodata(0, inplace=True)

    raster_base_label = raster_base_label.astype(output_dtype)
    raster_base_label.rio.write_nodata(0, inplace=True)

    # ----- merge class numbers and certainties into one array
    merge_im_quali = xarray_utils.merge_xarray_dict(
        {'class': raster_base_label, 'quali':raster_base_certainty},
        name_new_dim="band")

    # ---- save segmentation as raster
    file_name = f"{PARAM['prefix_out']}_segmentation_{PARAM['label_version']}_final_class_certainty.tif"
    geo_utils.save_to_geotiff(
        merge_im_quali, PARAM['PATH_LABELS'], file_name)




